#!/usr/bin/python3

import os
import sys

import argparse
import getpass
import shutil
import typing

from configparser import SectionProxy
from typeguard import typechecked
from lbox.utils import *

parser = argparse.ArgumentParser()
parser.add_argument("-n", "--name", type=str,
        help="""name of the box else the default is <distribution>-<conf_file> if not
                provided (trimming off .ini suffix from the <conf_file>)""")
parser.add_argument("-d", "--docker_path", type=str,
        help="path of docker/podman if not in /usr/bin")
parser.add_argument("distribution",
        help="short name of the distribution (should be in supported.list)")
parser.add_argument("conf_file",
        help="""the ini configuration file to be used for creating the linux box
                (should be in <distribution>/confs directory)""")
args = parser.parse_args()

distro = args.distribution
ini_suffix = ".ini"
if args.name:
    box_name = args.name
else:
    box_name = args.conf_file
    if box_name.endswith(ini_suffix):
        box_name = box_name[:-len(ini_suffix)]
    box_name = f"{distro}-{box_name}"

# check for podman first then docker
if args.docker_path:
    docker_cmd = args.docker_path
elif os.access("/usr/bin/podman", os.X_OK):
    docker_cmd = "/usr/bin/podman"
elif os.access("/usr/bin/docker", os.X_OK):
    docker_cmd = "/usr/bin/docker"
else:
    sys.exit("Neither /usr/bin/podman nor /usr/bin/docker found and no -d option provided")

# note: deliberately not using os.path.join since the code only works on Linux like
# systems where path separator will always be "/" so explicitly forcing the same

home_dir = os.environ['HOME']
# configuration files should be in $HOME/.config/linuxbox or /etc/linuxbox
config_dirs = [f"{home_dir}/.config/linuxbox", "/etc/linuxbox"]
# user data directory is $HOME/.local/share/linuxbox
data_dir = f"{home_dir}/.local/share/linuxbox"

# prepare for the additional environment variables and NOW substitution
os.environ["LINUXBOX_NAME"] = box_name
# local user home might be in a different location than /home but target user in the
# container will always be in /home as ensured by lbox-entrypoint.py script
target_user_home = "/home/" + getpass.getuser()
os.environ["TARGET_HOME"] = target_user_home
# set according to base.config_hardlinks and is false by default
config_hardlinks = False
# below variable can be set to true to skip $TARGET_HOME mounts for the case when
# user has still not been created in the container
skip_target_user = False


@typechecked
def get_config_file(f: str) -> str:
    for d in config_dirs:
        path = f"{d}/{f}"
        if os.access(path, os.R_OK):
            return path
    sys.exit(f"Configuration file {f} not found in [{', '.join(config_dirs)}]")

@typechecked
def add_mount_option(args: list[str], src: str, dest: str, flags: str = "") -> None:
    if flags:
        args.append(f"-v={src}:{dest}:{flags}")
    else:
        args.append(f"-v={src}:{dest}")

@typechecked
def add_env_option(args: list[str], envvar: str, envval: typing.Optional[str] = None) -> None:
    if envval is None:
        args.append(f"-e={envvar}")
    else:
        args.append(f"-e={envvar}={envval}")

@typechecked
def enable_xorg(args: list[str]) -> None:
    add_env_option(args, "DISPLAY")
    xsock = "/tmp/.X11-unix"
    add_mount_option(args, xsock, xsock, "ro")
    if (xauth := os.environ.get("XAUTHORITY")):
        add_mount_option(args, xauth, xauth, "ro")

@typechecked
def enable_pulse(args: list[str]) -> None:
    cookie = f"{os.environ['HOME']}/.config/pulse/cookie"
    if not skip_target_user and os.access(cookie, os.R_OK):
        add_mount_option(args, cookie, f"{target_user_home}/.config/pulse/cookie", "ro")
    if (xdg_rtdir := os.environ.get("XDG_RUNTIME_DIR")):
        pulse_native = f"{xdg_rtdir}/pulse/native"
        add_mount_option(args, pulse_native, pulse_native)

@typechecked
def enable_dbus(args: list[str], sys_enable: bool) -> None:
    if (dbus_user := os.environ.get("DBUS_SESSION_BUS_ADDRESS")):
        dbus_user = dbus_user[dbus_user.find("=") + 1:]
        if (dbus_opts_idx := dbus_user.find(",")) != -1:
            dbus_user = dbus_user[:dbus_opts_idx]
        add_mount_option(args, dbus_user, dbus_user)
    if sys_enable:
        dbus_sys = "/run/dbus/system_bus_socket"
        dbus_sys2 = "/var/run/dbus/system_bus_socket"
        if os.access(dbus_sys, os.W_OK):
            add_mount_option(args, dbus_sys, dbus_sys)
        elif os.access(dbus_sys2, os.W_OK):
            add_mount_option(args, dbus_sys2, dbus_sys)

@typechecked
def add_multi_opt(args: list[str], section: SectionProxy, key: str, opt: str) -> None:
    if (opts := section.get(key)):
        for opt_val in opts.split(";"):
            args.append(f"--{opt}={opt_val}")

@typechecked
def process_base_section(base_section: SectionProxy, args: list[str]) -> None:
    global config_hardlinks
    if not skip_target_user:
        add_env_option(args, "TARGET_HOME", target_user_home)
    for key in base_section:
        if key == "home":
            if not skip_target_user:
                source_home = base_section[key]
                # create the source directory if it does not exist
                os.makedirs(source_home, exist_ok=True)
                add_mount_option(args, source_home, target_user_home)
        elif key == "config_hardlinks":
            config_hardlinks = base_section.getboolean("config_hardlinks")
        elif key == "xorg":
            if base_section.getboolean("xorg"):
                enable_xorg(args)
        elif key == "pulseaudio":
            if base_section.getboolean("pulseaudio"):
                enable_pulse(args)
        elif key == "dbus":
            if base_section.getboolean("dbus"):
                enable_dbus(args, base_section.getboolean("dbus_sys", fallback=False))
        elif key == "dri":
            if base_section.getboolean("dri"):
                args.append("--device=/dev/dri")
        elif key == "nvidia":
            if base_section.getboolean("nvidia"):
                args.append("--device=nvidia.com/gpu=all")
        elif key == "pids_limit":
            pids_limit = base_section["pids_limit"]
            if pids_limit:
                args.append(f"--pids-limit={pids_limit}")
        elif key == "log_driver":
            log_driver = base_section["log_driver"]
            if log_driver:
                args.append(f"--log-driver={log_driver}")
        elif key == "log_opts":
            add_multi_opt(args, base_section, "log_opts", "log-opt")
        elif key != "includes" and key != "dbus_sys":
            sys.exit(f"Unknown key '{key}' in the [base] of {ini_file} or its includes")

@typechecked
def add_option_if_exists(args: list[str], section: SectionProxy, key: str, opt: str) -> None:
    if (val := section[key]):
        args.append(f"--{opt}={val}")

@typechecked
def add_sec_option_if_exists(args: list[str], sec_section: SectionProxy, key: str) -> None:
    if (val := sec_section[key]):
        args.append(f"--security-opt={key}={val}")

@typechecked
def process_security_section(sec_section: SectionProxy, args: list[str]) -> None:
    for key in sec_section:
        if key == "label":
            add_sec_option_if_exists(args, sec_section, "label")
        elif key == "apparmor":
            add_sec_option_if_exists(args, sec_section, "apparmor")
        elif key == "seccomp":
            add_sec_option_if_exists(args, sec_section, "seccomp")
        elif key == "seccomp_policy":
            add_option_if_exists(args, sec_section, "seccomp_policy", "seccomp-policy")
        elif key == "mask":
            add_sec_option_if_exists(args, sec_section, "mask")
        elif key == "unmask":
            add_sec_option_if_exists(args, sec_section, "unmask")
        elif key == "no_new_privileges":
            if sec_section.getboolean(key):
                args.append("--security-opt=no-new-privileges")
        elif key == "proc_opts":
            add_sec_option_if_exists(args, sec_section, "proc-opts")
        elif key == "caps_add":
            add_multi_opt(args, sec_section, "caps_add", "cap-add")
        elif key == "caps_drop":
            add_multi_opt(args, sec_section, "caps_drop", "cap-drop")
        elif key == "cgroup_parent":
            add_option_if_exists(args, sec_section, "cgroups_parent", "cgroups-parent")
        elif key == "cgroup_confs":
            add_multi_opt(args, sec_section, "cgroup_confs", "cgroup-conf")
        elif key == "cgroupns":
            add_option_if_exists(args, sec_section, "cgroupns", "cgroupns")
        elif key == "cgroups":
            add_option_if_exists(args, sec_section, "cgroups", "cgroups")
        elif key == "device_cgroup_rules":
            add_multi_opt(args, sec_section, "device_cgroup_rules", "device-cgroup-rule")
        elif key == "secrets":
            add_multi_opt(args, sec_section, "secrets", "secret")

@typechecked
def process_mounts_section(mounts_section: SectionProxy, args: list[str]) -> None:
    for key in mounts_section:
        # keys here are only symbolic names and serve no purpose other than allowing
        # later configuration files to override previous ones
        if (val := mounts_section[key]):
            if "=" in val or "," in val:
                args.append(f"--mount={val}")
            else:
                args.append(f"-v={val}")

@typechecked
def process_env_section(env_section: SectionProxy, args: list[str]) -> None:
    for key in env_section:
        add_env_option(args, key, env_section[key])

# see os.link(..., follow_symlinks=True) broken on Linux:
# https://github.com/python/cpython/issues/81793
# (the '*' in signature is from shutil.copy that indicates only keyword args allowed after it)
@typechecked
def hardlink(src: str, dst: str, *, follow_symlinks=True) -> str:
    os.link(os.path.realpath(src), dst, follow_symlinks=follow_symlinks)
    return dst

@typechecked
def process_configs_section(configs_section: SectionProxy, args: list[str]) -> None:
    # copy or link the mentioned files in [configs] section which can be either files
    # or directories (recursively copy/link in the latter case)
    # this is refreshed on every container start
    configs_dir = f"{data_dir}/{box_name}/configs"
    # always recreate the directory to pick up any changes
    if os.path.exists(configs_dir):
        shutil.rmtree(configs_dir)
    os.makedirs(configs_dir, exist_ok=True)
    if config_hardlinks:
        print(fgcolor.blue, "Creating hard links to paths in [configs]", fgcolor.reset, sep="")
    else:
        print(fgcolor.blue, "Creating a copy of paths in [configs]", fgcolor.reset, sep="")
    for key in configs_section:
        val = configs_section[key]
        split_idx = val.find("->")
        if split_idx == -1:
            sys.exit("Incorrect value format in [configs] section for "
                    f"'{key}'. Required: '{{src}} -> {{dest}}'")
        src_path = os.path.realpath(val[:split_idx].strip())
        dest_path = f"{configs_dir}/{val[split_idx + 2:].strip()}"
        if os.access(src_path, os.R_OK):
            os.makedirs(os.path.dirname(dest_path), exist_ok=True)
            if os.path.isdir(src_path):
                if config_hardlinks:
                    shutil.copytree(src_path, dest_path, symlinks=False,
                                    copy_function=hardlink)
                else:
                    shutil.copytree(src_path, dest_path, symlinks=False)
            else:
                if config_hardlinks:
                    hardlink(src_path, dest_path, follow_symlinks=True)
                else:
                    shutil.copy2(src_path, dest_path, follow_symlinks=True)
        else:
            print(fgcolor.red, f"Skipping inaccessible configuration path '{src_path}'",
                  fgcolor.reset, sep="")


support_list = get_config_file("supported.list")
# check that the distribution is in supported.list
with open(support_list, "r") as supp_file:
    if distro not in supp_file.read().splitlines():
        sys.exit(f"Distribution '{distro}' not supported in {support_list}")

# the ini configuration file used to build the docker/podman command-line
ini_file = get_config_file(f"{distro}/confs/{args.conf_file}")

# read the config file, recursively reading the includes if present,
# then replace the environment variables and the special ${NOW:...} from all values
config = config_postprocess(config_reader(ini_file))
# finally process all the sections and the keys forming the docker/podman command-line
docker_args = []
for section in config.sections():
    if section == "base":
        process_base_section(config["base"], docker_args)
    elif section == "security":
        process_security_section(config["security"], docker_args)
    elif section == "mounts":
        process_mounts_section(config["mounts"], docker_args)
    elif section == "env":
        process_env_section(config["env"], docker_args)
    elif section == "configs":
        process_configs_section(config["configs"], docker_args)
    elif section != "apps" and section != "startup":
        sys.exit(f"Unknown section [{section}] in '{ini_file}' or one of its includes")

# determine the image name
distro_config = config_reader(get_config_file(f"{distro}/distro.ini"))
image_name = distro_config["base"]["image"]

print(fgcolor.purple, f"Command to be run: {docker_cmd} run -itd --name={box_name} ",
        f"{' '.join(docker_args)} {image_name} /usr/bin/tail -s10 -f /dev/null", fgcolor.reset, sep="")
